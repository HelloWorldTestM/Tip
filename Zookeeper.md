# ZooKeeper
--
### ACID
* **A** 原子性
* **C** 一致性
* **I** 隔离性
* **D** 持久性

### CAP
* **C 一致性** 在分布式系统中，如果针对一个数据项的更新操作执行成功后，所有用户都能够读取到最新的值，那么这样的系统可以认为是强一致性。
* **A 可用性** 系统提供的服务必须一致处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。
* **P 分区容错性** 分布式系统在遇到任何网络分区故障的时候，仍然需要能够对外提供满足的一致性和可用性服务


# ZAP协议
--

```
ZAB协议并不像Paxos算法那样，是一种通用的分布式一致算法，他是一种特别为Zookpeer设计的崩溃可恢复的原子消息广播算法。 
```
Zookeeper使用**一个单一的主进程**来接受并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更以Proposal的形式广播到所有的副本进程上去，ZAB协议的这个主备架构保证了同一时刻只有一个主进程来广播服务器状态的变更。

> ZK被设计成只允许唯一的Leader服务器进行来进行事务请求的处理，Leader服务器接收到客户端的事务请求后，会生成对应的事务提案，并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非leader服务器就会将这个事务请求转发给leader服务器。

ZAB协议包含两种基本的模式，分别是`崩溃恢复`和`消息广播`。

1. `崩溃恢复`
	* `进入恢复模式的触发条件`。当整个服务框架在启动过程中，或是当`Leader`服务器出现**网络中断**、**崩溃退出**与**重启**等异常状况时，`ZAB`协议就会进入恢复模式，并选举产生新的Leader服务器。
	* `恢复模式退出条件`。`Leader`机器产生，并且已经有过半的机器与`leader`进行了同步，之后就进入`消息广播阶段`。
	
	> ps: 当一台服务器启动后并加入到集群中时，新加入的机器就会自动进入崩溃恢复模式。

2. `消息广播`
	* 在消息广播的过程中，`Leader`服务器会为每一个`follower`服务器各自分配一个单独的队列，然后将需要广播的事务`Proposal`依次放入这些队列中去，并根据`FIFO`策略进行消息发送。每一个`follower`服务器在接收到这个事务的`proposal`之后，都会首先将其以事务的形式写入到本地磁盘中去，并且在写入成功后反馈给`leader`服务器一个`Ack`响应。当`leader`服务器接收到超过半数的`Follower`的Ack响应之后，就会广播一个`Commit`消息给所有的`Follower`服务器以通知其进行事务提交，同时`leader`自身也会完成对事务的提交。



# ZooKeeper基本知识

1. znode  节点可以是临时节点也可以是持久节点，临时的znode节点在创建者的会话过期是删除，所以不允许临时节点含有子节点。
2. znode 节点一共四种类型：
    1. 持久类型
    2. 临时类型
    3. 持久有序类型
    4. 临时有序类型
     
    >其中有序的类型是在节点之后分配一个单调递增的整数，当创建路径时，整数就会追加到路径之后。
3. znode 的数据更新采用了通知机制。也就是当对一个znode进行更新时，先向监视它的客户端发送通知，然后在对这个节点进行变更。然后在对变更后的数据进行读取。
4. znode 的版本
    * 每个znode都有一个版本号，而且它每次随着数据的变化自增。setData和delete这两个调用以版本号作为传入参数，至于当传入参数的版本号与服务器上的版本号一致时调用才会成功。当多个Zookeeper客户端对同一个znode进行操作时，版本号能保证数据的一致性。
5. 关于zookeeper使用奇数台2服务器作为follower/master的原因：
    * 因为zookeeper的多数方案，使用偶数台服务器会是系统变得脆弱。例如使用5台机器的容错数量是2，而使用6台机器的容错数量也是2。
6. zookeeper实现锁使用的是临时节点，因为如果使用永久节点，当获得锁的那个进行挂掉之后，可能会导致这个锁永远无法释放。
7. zookeeper 中节点之间的通信是通过在znode上创建临时节点，其他节点监视这一节点的状态。当临时节点消失时，表明对应的主机已经下线。一般存放在/workers节点下，下一级节点是临时节点。
8. zookeeper 默认的数据存储路径为 /tmp/zookeeper ，初始化时要在数据路径下增加myid文件，这个路径要记得更换，如果用默认的路径，myid文件会丢失，导致启动错误，或终止.
9. 客户端使用Watcher接口来监控与ZooKeeper之间绘画的健康状况，与zookeeper之间建立或失去连接时就会产生事件，最终如果zookeeper的会话过期，也会通过Watcher接口传递事件来通知客户端的应用。
10. zookeeper处理状态变化的重要机制—监视点（watch），通过监视点，客户端可以对指定的znode节点注册一个通知请求，在发生变化时就会收到一个单次的通知。
11. 当一个监视点被一个事件（znode节点数据被赋值，被删除等）触发时，就会产生一个通知。通知是向所有注册了监视点的应用客户端发送报告消息。
12. 客户端设置的每一个监视点会与会话关联，如果会话过期，等待中的监视点将会被删除。不过监视点可以跨越不同的服务端进行连接，并不一定要在设置了那个监视点的服务端才会收到通知。
13. ZooKeeper的API中的所有读操作：getData、getChildren和exists，均可选择在读取的znode节点上设置监视点。使用监视点机制，我们需要实现Watcher接口类。实现其中的process方法。
14. 监视点有两种类型：数据监视点和子节点监视点。创建、删除或设置一个znode节点的数据都会触发数据监视点。
15. 对于监视点的一个重要问题是，一旦设置监视点就无法移除。想要移除一个监视点，只有两个方法，一是触发这个监视点，二是使其会话被关闭或过期。
16. 举例说明监视点：当znode节点/z被删除，客户端需要知道该变化，客户端在/z节点执行exists操作并设置监视点标志位，等待通知，客户端会以回调函数的形式收到通知。
17. 对于zookeeper，开发人员往往负责管理访问控制的权限，而不是管理员。这时因为每次穿件znode节点时，必须设置访问权限，而且子节点并不会继承父节点的访问权限。访问权限的检查也是基于每一个znode节点的，如果一个客户端可以访问znode节点，即使这个客户端无权访问该节点的父节点，仍然可以访问这个znode节点。



